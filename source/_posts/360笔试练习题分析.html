<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<table>
<tbody>
<tr class="odd">
<td>title: 360笔试练习题分析</td>
</tr>
<tr class="even">
<td>date: 2016-09-19 21:24:38</td>
</tr>
<tr class="odd">
<td>tags: 数据结构 java</td>
</tr>
</tbody>
</table>
<table style="width:4%;">
<colgroup>
<col width="4%" />
</colgroup>
<thead>
<tr class="header">
<th>某一系统功能，需要一次性加载N（N在1000左右）个随机数，后续只对该集合执行遍历操作，最宜采用那种数据结构？ 链表</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>数组</strong>：连续存储，遍历快且方便，长度固定，缺点：移除和添加 对于长度固定，在某些场合也是一个缺陷； <strong>链表</strong>：离散存储，添加删除方便，空间和时间消耗大；双向链表较方便，但空间消耗更大； <strong>Hash表</strong>：数据离散存储，利用hash算法确定存储位置，遍历麻烦； <strong>二叉树</strong>：一般的查找遍历有深度优先和广度优先，遍历分前续、中序和后序，效率都差不多，如果数据经过排序，效率还是很不错的； <strong>图</strong>:表示物件与物件之间关系的数学对象，常用遍历方式有深度优先遍历和广度优先遍历，这两种方式对有向和无向图均可以，遍历查找不及前面任何一种结构。</td>
</tr>
</tbody>
</table>
<h2 id="精俭排序即一对数据不进行两次或两次以上的比较以下是精俭排序的是-插入排序归并排序">精俭排序，即一对数据不进行两次或两次以上的比较，以下是精俭排序的是： 插入排序、归并排序。</h2>
<p><strong>插入排序</strong>： 该排序一般从第二个元素开始遍历，依次与前一个比较，若小于，则将该元素依次与前面所有的元素比较，将比它大的元素依次后移，为该元素腾出位置将其放入即可；若大于，则维持该顺序，所以在整个排序过程中，没两个元素之间仅比较了一次。即精俭排序。 <strong>归并排序</strong>: 精俭排序 <strong>选择排序</strong>： 一般选择排序都是将当前元素与其后面的所有元素进行比较，找出其后的最小元素，交互它们的位置，所以在比较过程中会进行多次比较，即非精俭排序。 <strong>堆排序</strong>: 非精俭排序</p>
<table style="width:4%;">
<colgroup>
<col width="4%" />
</colgroup>
<thead>
<tr class="header">
<th>下面不是面向对象的基本原则的是： 抽象类原则（Abstruct-Class principle);</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>*单一职责原则（Single-Resposibility principle)**：就是一个类只负责一个职责，只有一个引起变化的原因。 *开放封闭原则（Open-Closed principle)**：这是所有面向对象原则的核心，软件设计本身所追求的目标就是封装变化，降低耦合，而开放封闭原则正是对这一目标的最直接提现。即软件实体应该对外扩展开放，而对修改封闭。 *依赖倒置原则（Dependecy-Inversion principle)**:就是要依赖于抽象，不要依赖于具体。简单的说就是对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块之间的耦合。一般就是下层依赖上层，下层的修改不会影响上层。 *迪米特法则**：又叫最少知识原则（Least Knowledge principle),就是说一个对象应当对其他对象有尽可能少的了解。 *组合/聚集复用原则（Composite/Aggregate Reuse principle)**：顾名思义，组合/聚合和继承是实现复用的两个基本途径，合成复用原则是指尽量使用合成/聚合，而不是使用继承。</td>
</tr>
</tbody>
</table>
<h2 id="接口是一种引用类型在接口中可以声明但不能声明公有的域或私有的成员变量">接口是一种引用类型，在接口中可以声明（），但不能声明公有的域或私有的成员变量。</h2>
<p>接口中只能包含方法、属性、索引器和事件的声明。不允许声明成员上的修饰符，即使是public都不行，因为接口成员都是公有的，也不能声明为虚拟和静态的。如果需要修饰符，最好让实现类来声明。所以对比一个类，接口的特性是：当定义一个类时，可以派生自多重接口，而你只能可以从一个类派生。</p>
<table style="width:4%;">
<colgroup>
<col width="4%" />
</colgroup>
<thead>
<tr class="header">
<th>flash和js通过什么类，如何交互?</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>使用ExternalInterface类进行交互。</td>
</tr>
</tbody>
</table>
<h2 id="设一个链表最常用的操作是在末尾插入结点和删除尾结点则选用最节省时间">设一个链表最常用的操作是在末尾插入结点和删除尾结点，则选用（）最节省时间？</h2>
<p>带头结点的双循环链表</p>
<table>
<tbody>
<tr class="odd">
<td>用有向无环图描述表达式（A+B)*((A+B)/A)，至少需要顶点的数目为（）。</td>
</tr>
</tbody>
</table>
<p>5</p>
</body>
</html>
