---
title: 360笔试练习题分析
date: 2016-09-19 21:24:38
tags: datastructure、java
---

1.某一系统功能，需要一次性加载N（N在1000左右）个随机数，后续只对该集合执行遍历操作，最宜采用那种数据结构？ 链表

**数组**：连续存储，遍历快且方便，长度固定，缺点：移除和添加  对于长度固定，在某些场合也是一个缺陷；
**链表**：离散存储，添加删除方便，空间和时间消耗大；双向链表较方便，但空间消耗更大；
**Hash表**：数据离散存储，利用hash算法确定存储位置，遍历麻烦；
**二叉树**：一般的查找遍历有深度优先和广度优先，遍历分前续、中序和后序，效率都差不多，如果数据经过排序，效率还是很不错的；
**图**:表示物件与物件之间关系的数学对象，常用遍历方式有深度优先遍历和广度优先遍历，这两种方式对有向和无向图均可以，遍历查找不及前面任何一种结构。
 
2.精俭排序，即一对数据不进行两次或两次以上的比较，以下是精俭排序的是： 插入排序、归并排序。

 **插入排序**： 该排序一般从第二个元素开始遍历，依次与前一个比较，若小于，则将该元素依次与前面所有的元素比较，将比它大的元素依次后移，为该元素腾出位置将其放入即可；若大于，则维持该顺序，所以在整个排序过程中，没两个元素之间仅比较了一次。即精俭排序。
 **归并排序**:  精俭排序
 **选择排序**： 一般选择排序都是将当前元素与其后面的所有元素进行比较，找出其后的最小元素，交互它们的位置，所以在比较过程中会进行多次比较，即非精俭排序。
 **堆排序**: 非精俭排序
 
3.下面不是面向对象的基本原则的是： 抽象类原则（Abstruct-Class principle)。

**单一职责原则（Single-Resposibility principle)**：就是一个类只负责一个职责，只有一个引起变化的原因。
**开放封闭原则（Open-Closed principle)**：这是所有面向对象原则的核心，软件设计本身所追求的目标就是封装变化，降低耦合，而开放封闭原则正是对这一目标的最直接提现。即软件实体应该对外扩展开放，而对修改封闭。
**依赖倒置原则（Dependecy-Inversion principle)**:就是要依赖于抽象，不要依赖于具体。简单的说就是对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块之间的耦合。一般就是下层依赖上层，下层的修改不会影响上层。
**迪米特法则**：又叫最少知识原则（Least Knowledge principle),就是说一个对象应当对其他对象有尽可能少的了解。
**组合/聚集复用原则（Composite/Aggregate Reuse principle)**：顾名思义，组合/聚合和继承是实现复用的两个基本途径，合成复用原则是指尽量使用合成/聚合，而不是使用继承。

4.接口是一种引用类型，在接口中可以声明（），但不能声明公有的域或私有的成员变量。

接口中只能包含方法、属性、索引器和事件的声明。不允许声明成员上的修饰符，即使是public都不行，因为接口成员都是公有的，也不能声明为虚拟和静态的。如果需要修饰符，最好让实现类来声明。所以对比一个类，接口的特性是：当定义一个类时，可以派生自多重接口，而你只能从一个类派生。

6.flash和js通过什么类，如何交互?

使用ExternalInterface类进行交互。 
 
7.设一个链表最常用的操作是在末尾插入结点和删除尾结点，则选用（）最节省时间？

带头结点的双循环链表


8.用有向无环图描述表达式（A+B)*((A+B)/A)，至少需要顶点的数目为（）。5


一些额外的知识点记录下来：
1.对Web标准和W3C规范的理解？
Web标准简单来说分为三部分，即html,css和javascript，也就是常说的结构、表现和行为，web标准一般是把这三部分独立分开，使其更具有模块化。
W3C对web标准提出了规范化的要求，也就是在实际开发中的一些代码规范。
2.列举块级元素和行内元素：
行内元素: a,em,strong,span,i,b,img,input,label,select,textarea
块级元素：div,ul,li,dd,dt,dl,ol,p,h1~h6,table,form,fieldset
3.列举浏览器的内核：
IE：Trident，Chrome：Webkit，Firefox：Gecko
4.Ajax中post和get请求的区别？
使用get请求时，参数在URL中显示，而post不是，其将参数放在body中，不会直接显示出来；
使用get传递参数大小有限制，大约在1k左右，这个限制并不是http协议规定，应该是浏览器对URL的大小有限制，所以也就相当于限制了参数的大小，而post对参数大小没有限制；
get请求默认是会被浏览器缓存的，因为对于同一URL，浏览器会认为其结果是一样的，所以当第二次请求时会直接使用上一次的结果，而浏览器认为post请求是变动的，所以其请求不会被缓存，另外若要避免缓存get请求，则给get请求添加一个参数如`?t=new Date()`,可达到目的；
在使用ajax的xhr对象发送请求时，由于get请求不会在请求体中传递参数，所以需要传递一个null参数，而post直接传递参数即可；
    post请求必须设置header的Content-Type的值为`application/x-form-www-urlencoded`，确保服务器知道实体中有参数变量，可以使用xmlHttpRequest对象的如下方法:

``` javascript
//嵌入javascript代码总导致页面的解析错误！！
setRequestHeader('content-type','application/x-form-www-urlencoded');
```

